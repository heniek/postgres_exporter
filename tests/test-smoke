#!/bin/bash
# Basic integration tests with postgres. Requires docker to work.

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

# Read the absolute path to the exporter
postgres_exporter=$(readlink -f $1)
test_binary=$(readlink -f $2)
POSTGRES_PASSWORD=postgres
exporter_port=9187

cd $DIR

VERSIONS=( \
    9.1 \
    9.2 \
    9.3 \
    9.4 \
    9.5 \
    9.6 \
)

wait_for_replicated_postgres() {
    local CONTAINER_NAME=$1
    if [ -z $CONTAINER_NAME ]; then
        echo "No container name specified." 1>&2
        exit 1
    fi
    local WAIT_START=$(date +%s)
    echo "Waiting for postgres to initialize..."
    while ! docker exec $CONTAINER_NAME bash -c "test -e /tmp/.postgres_init_complete" ; do
        if [ $(( $(date +%s) - $WAIT_START )) -gt $TIMEOUT ]; then
            echo "Timed out waiting for postgres!" 1>&2
            exit 1
        fi
        sleep 1
    done
    echo "Waiting for postgres to start..."
    while ! docker exec $CONTAINER_NAME bash -c "psql -U postgres -c \"select 'running'\" > /dev/null 2>&1 " ; do
        if [ $(( $(date +%s) - $WAIT_START )) -gt $TIMEOUT ]; then
            echo "Timed out waiting for postgres!" 1>&2
            exit 1
        fi
        sleep 1
    done
}

wait_for_postgres() {
    local CONTAINER_NAME=$1
    if [ -z $CONTAINER_NAME ]; then
        echo "No container name specified." 1>&2
        exit 1
    fi
    local WAIT_START=$(date +%s)
    echo "Waiting for postgres to start..."
    while ! docker exec $CONTAINER_NAME bash -c "psql -U postgres -c \"select 'running'\" > /dev/null 2>&1 " ; do
        if [ $(( $(date +%s) - $WAIT_START )) -gt $TIMEOUT ]; then
            echo "Timed out waiting for postgres!" 1>&2
            exit 1
        fi
        sleep 1
    done    
}

wait_for_exporter() {
    local DAEMON_WAIT_START=$(date +%s)
    echo "Waiting for exporter to start..."
    while ! nc -z localhost $exporter_port ; do
        if [ $(( $(date +%s) - $DAEMON_WAIT_START )) -gt $TIMEOUT ]; then
            echo "Timed out waiting for exporter!" 1>&2
            exit 1            
        fi
        sleep 1
    done
}

smoketest_postgres() {
    local version=$1
    local CONTAINER_NAME=postgres_exporter-test-smoke
    local TIMEOUT=30
    local IMAGE_NAME=postgres
    
    local CUR_IMAGE=$IMAGE_NAME:$version
    
    echo "#######################"
    echo "Standalone Postgres $version"
    echo "#######################"
    local docker_cmd='docker run -d -e POSTGRES_PASSWORD=$POSTGRES_PASSWORD -p 127.0.0.1:55432:5432 $CUR_IMAGE'
    echo "Docker Cmd: $docker_cmd"
    
    CONTAINER_NAME=$(eval $docker_cmd)
    trap "docker logs $CONTAINER_NAME ; docker kill $CONTAINER_NAME ; docker rm -v $CONTAINER_NAME; exit 1" EXIT INT TERM
    wait_for_postgres $CONTAINER_NAME

    DATA_SOURCE_NAME="postgresql://postgres:$POSTGRES_PASSWORD@localhost:55432/?sslmode=disable" $test_binary --log.level=debug || exit $?
#    exporter_pid=$!
#    trap "docker logs $CONTAINER_NAME ; docker kill $CONTAINER_NAME ; docker rm $CONTAINER_NAME ; kill $exporter_pid; exit 1" EXIT INT TERM
#    wait_for_exporter
#
#    wget -q -O - http://localhost:$exporter_port/metrics 1> /dev/null
#    if [ "$?" != "0" ]; then
#        echo "Failed on postgres $version ($DOCKER_IMAGE)" 1>&2
#        kill $exporter_pid
#        exit 1
#    fi
#
#    kill $exporter_pid
    docker kill $CONTAINER_NAME
    docker rm $CONTAINER_NAME
    trap - EXIT INT TERM
    
    echo "#######################"
    echo "Replicated Postgres $version"
    echo "#######################"
    old_pwd=$(pwd)
    cd docker-postgres-replication
    
    VERSION=$version p2 -t Dockerfile.p2 -o Dockerfile
    if [ "$?" != "0" ]; then
        echo "Templating failed" 1>&2
        exit 1
    fi
    trap "docker-compose logs; docker-compose down ; docker-compose rm -v; exit 1" EXIT INT TERM
    local compose_cmd="POSTGRES_PASSWORD=$POSTGRES_PASSWORD docker-compose up -d --force-recreate --build"
    echo "Compose Cmd: $compose_cmd"
    eval $compose_cmd
    
    master_container=$(docker-compose ps -q pg-master)
    slave_container=$(docker-compose ps -q pg-slave)
    master_ip=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $master_container)
    echo "Got master IP: $master_ip"
    wait_for_replicated_postgres $master_container
    wait_for_replicated_postgres $slave_container
    
    DATA_SOURCE_NAME="postgresql://postgres:$POSTGRES_PASSWORD@$master_ip:5432/?sslmode=disable" $test_binary --log.level=debug || exit $?
#    exporter_pid=$!
#    trap "docker-compose logs; docker-compose down ; docker-compose rm -v ; kill $exporter_pid; exit 1" EXIT INT TERM
#    wait_for_exporter

#    wget -q -O - http://localhost:$exporter_port/metrics 1> /dev/null
#    if [ "$?" != "0" ]; then
#        echo "Failed on postgres $version ($DOCKER_IMAGE)" 1>&2
#        exit 1
#    fi
#
#    kill $exporter_pid
    
    docker-compose down
    docker-compose rm -v
    trap - EXIT INT TERM
    
    cd $old_pwd
}

# Start pulling the docker images in advance
for version in ${VERSIONS[@]}; do
    docker pull postgres:$version > /dev/null &
done

for version in ${VERSIONS[@]}; do
    echo "Testing postgres version $version"
    smoketest_postgres $version
done
